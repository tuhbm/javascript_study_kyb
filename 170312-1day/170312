자바스크립트의 핵심
기능 - Control
자바스크립트로 혼자서 할 수 있는 것은 없음.
자바스크립트 개발자는 돔 및 서버사이드까지 알아야한다. 시간이오래걸린다

기술 - Object(name:value)

dom - html, css
html5 api


function 오프젝트(함수)
스크립트 <script> 실행시 내장함수를 만든다.
함수의 호출은 객체 형태이어야한다.
빌트인(내장함수) 오브젝트로 함수객체 생성 - 인스턴스개념
함수는 객체라고 인식을 해야한다.
ES6는 객체지향적으로 구조를 작성
함수를 호출시 함수이름을 검색하여 value 값을 구하고, value가 함수객체면 실행.
함수가 호출되면 엔진은 {키 : 벨류}의 형태의 프로퍼티를 조합
자바스크립트의 결론은 키 : 밸류형태 (이름 : 값)의 형태

아키텍쳐와 메커니즘

아키텍처
목적을 가진 구조
자바스크립트 목적을 달성하기 위한 구조

매커니즘
목적을 달성하기 위한 방법

자바스크립트의 목적
자바스크립트는 프로그래밍 언어
언어의 먹적은 소통이다
자바스크립트 프로그램의 목적
프로그램을 통해 자바스크립트와 소통
문법을 지켜야 소통이 가능(문법은 기본을 지키는것뿐)
자바스크립트의 상태파악(아키텍처와 매커니즘 이해)

엔진의 함수 오브젝트 생선 순서와 방법

함수 오브젝트를 생성
function sport(){}
sport는 생성한 함수의 이름
오브젝트 타입니 함수이면 빈 오브젝트이다.

오브젝트의 프로토타입 오브젝트를 첨부
프로토타입에 컨스트럭쳐 프로퍼티를 추가
프로토타입.컨스트럭쳐에서 sport객체를 참조할수있도록 설정
-따라서 컨스트록쳐의 프로퍼티와 sport오프젝트의 프로퍼티가 같아진다.
프로토타입에 _proto_오프젝트를 첨부
-es5기준에서보면 포준은 아님
-하지만 es6스팩에 게제한것이지 이구조를 사용

내장함수 객체의 프로토타입에 연결된 프로퍼티로 객체인스턴스를 생성하여 프로토타입_proto_에 첨부
모든 객체내에 내장함수가 있다.

실행 환경 인식의 필요성
함수가 호출퇴었을때 실행될 환경을 인식(환경에 맞추어 함수를 실행)
오브젝트를 생성하하는 시점에 실행환경 설정(함수에 작성한 코드,실행영역,파라미터등)

내부 프로퍼티란
엔진이 내부에 처리에서 사용하는 프로퍼티
외부에서 접근불가
[[]]형태 예시:[[scope]]

내부프로퍼티의 분류 - 공통프로퍼티,선택적 프로퍼티
프로퍼티 이름
프로토타입 - 오브젝트의 프로토타입
클래스 - 오브젝트 유형 구분
프로퍼티 = 키:벨류
속성(확장가능여부,삭제가능여부,열거가능여부)
스코프 - 오브젝트가 실행되는 렉시컬(정적) 환경

함수의 정의
ㄴ3가지형태
    -함수선언문
    -함수 표현식
        ㄴ실행결과(객체)를 변수에 반환하는 식
    -new Function(param1,param2,body)
        ㄴ가끔사용
        ㄴ문자열로 작성
함수선언문
ㄴfunction 이름(){}
ㄴ키워드(function)와 함수이름 작성은 필수
ㄴ파라미터는 선택

함수표현식
ㄴ이름이 없는 함수 (익명함수)
ㄴ보통 변수에 할당
ㄴ예시:var name = function(){}

함수를 안에서 생성하여 밖에서 호출

엔진의 해석
-자바스크립트는 스크립팅 언어
-위에서부터 한줄씩 해석하지만 약깐의 차이는 있다.
-중간에 먼저 해석 될 수 있다.
    ㄴ함수 선언문 먼저 해석
    ㄴ후에 함수 표현식 해석

코드해석순서
1.함수 선언문 해석
2.변수 초기화
3.자바스크립트 코드 실행

함수앞에서 호출
함수선언문은 초기화상태에서
함수 객체를 생성하므로
함수 호출하는 위치에 영향을 받지않음
함수 앞에서 호출가능
function sports(){
    baseball();
    function baseball(){console.log(good)}
}

함수 선언문 오버라이딩(대체)
함수 이름이 같은떄 함수 코드 대체
파라미터 수 데이터 타입 체크하지않음
ㄴkey:value로 저장하기 떄문에
-형태
초기화단계에서 함수 선언문을 함수오브젝트생성


실험1

함수선언문 , 호출, 함수선언문
결과 : 전자

함수 표현식 , 호출 , 함수표현식
결과 : 후자

함수 선언문 , 호출 , 함수 표현식
결과 : 후자

함수 표현식 , 호출 , 함수 선언문
결과 : 후자


argument 객체

파라미터의 상호관계
호출하는 함수 - 값 전송
호출 받는 함수 이름으로 받음

파라미터 작성 처리 기준
호출받는 함수의 파라미터에 이름 작성
호출받는 함수의 파라미터에 값 작성
호출한 삼수에서 보낸 값을 작성 순서에 맞추어 맵핑
호출됨 함수의 첫번쨰 파라미터에 첫번째 값 설정

파라미터의 이름 작성 목적
재사용등 사용성을 고려

호출받는 기준으로 수가 다를때도 호출 가능
다른언어는 수가 다르면 에러가 발생

호출한 함수의 파라미터 값이 순서대로 저장
호출한 함수의 파라미터 값을 작성하지 않아도 생성된다.
호출 받음 함수 안에서만 사용가능하다.

콜은 파라미터가 갯수 정해져있다.
어플라이는 배열로 갯수가 정해져있지 않으므로 배열로 넘긴다.

arguments의 장단점
파라미터 수가 고정일때
파라미터 이름 사용

length 프로퍼티
호출함 함수의 파라미터 수

문자열, 슷지,배열,불린 다양한 형태 사용 가능
파라미터 순서를 0부터 인덱스를 부여하여 key로 사용
파라미터로 받음 값을 value에 설정
arguments는 for in문이 아닌 for문으로 돌려야한다(키 벨류 형태이므로)

arguments 엔진처리 (호출받는 함수의 파라미터 수만큼 반복)
1. 함수호출
2. 파라미터값 할당
3. arguments 오브젝트 생성
4. 함수 코드 실행

스코프
함수가 실행될때 영향을 받는 범위
ex:>
split()는 string 오브젝트에 존재하므로 string 오브젝트가 스코프

스코프의 사용목적
범위제한, 신속산 검색&접근
같은 프로퍼티 이름 사용 가능
String의 indexOf(), Array의 indexOf()

스코프의 구조
-계층적 구조
-스코프 안에 스코프가 있는 형태

스코프의 설정 시점
-함수 오프젝트를 생성할때(정적 스코프)
-함수를 호출할떄 설정되지 않음(동적스코프)
따라서 function안에 코드에대해서는 구조를 만들지 않음

밖에서 안으로 들어가면서 스코프 구조 형성
반면에 안에서 밖으로 나가면서 스코프 범위 검색

글로벌 오브젝트
첫번쨰 <script>에서 한번만 생성(빌트인 오브젝트 - 내장함수)
자바스크립트 실행 환경설정
<script>의 프로그램 실행전에 생성
new 연산자 사용 불가

글로벌 스코프
-전체를 통해 하나만 존재하므로 스코프도 하나
-최상위 스코프
    ㄴ검색한 프로퍼티가 없으면 undefined
-스코프 설정
    ㄴfunction 오브젝트의 [[scope]]에 설정


undifined 와 null
undifined 설정값이 없다
null 사용자가 직접 없다고 설정한것

함수구분
-지역함수(로컬함수), 전역함수(글로벌함수)
-함수 안에서 var 키워드를 사용한 함수와 함수 선언문사용
-함수 안에서 var 키워드를 사용하지 않으면 글로벌 함수
-strict 모드 일 떄 var를 사용하지 않고 함수를 선언하면 에러
-글로벌 오브젝트에서  var 키워드를 사용하여 함수선언 가능
-글로벌 지역관계없이 표현식 함수는 var를 사용

지역함수
-함수 안에서 검색

함수호출
-글로벌 함수
    ㄴ어느위치에서도 함수 호출
-지역 함수
    ㄴ함수 안으로 들어가야 함수 호출 가능

user strict 모드 사용 필수

binding
-구조적으로 결속된 상태로 만드는것
-대상 : 오브젝트와 프로퍼티의 이름
-바인딩의 목적
    ㄴ스코프 결정
    ㄴ오브젝트에서 이름 식별
-바인딩 시점 분류
    ㄴ정적바인딩(Lexical or Static binding)
    ㄴ동적바인딩(Dynmic Binding)

스코프체인
-스코프가 상하 구조로 연결된 개념/구조
-스코프 체인을 사용하여 근접한 스크프에서 프로퍼티(함수,변수)검색
-es3에서 채용
-es5에서 스코프체인 용어폐지
-렉시컬 환경(정적환경) 사용

바인딩 시점
-정적바인딩
    ㄴ초기화 단계에서 바인딩
    ㄴ변수 함수 표현식에서 초깃값 설정 : undefined
    ㄴ함수 선언문 : function 객체생성
    ㄴ대부분 함수가 정적 바인딩
    ㄴ이미 바인딩 된 함수 안에서 함수밖에 스코프 설정 불가
-동적바인딩
    ㄴ실행단계에서 바인딩
    ㄴeval 함수, with문
    ㄴuser strict 모드에서 사용하면 에러 발생
-바인딩 시점이 중요한 이유
    ㄴBinding시점에 Scope가 결정되기 때문에
    ㄴFunction Object 생성 시점에 Scope 결정
    ㄴ인식한 Scope를 [[Scope]] 에 설정
    ㄴ정적 Binding은 [[Scope]]를 Scope로 사용하므로 변경되지 않음
    ㄴ같은 단계의 모든 함수는 Scope가 같다.


실행 콘텍스트
-함수의 실행영역
-함수 코드를 실행하고 실행 결과를 저장
-ES5 스펙상의 사양
    ㄴ외부 프로그램에서 접근 불가
-실행 콘텍스트 처리 단계
    ㄴ1.준비단계
    ㄴ2.초기화단계
    ㄴ3.코드 실행 단

렉커컬 환경
-렉시컬 환경은 function, with, try-catch에서 생성
-렉시컬 환경 구성형태
    ㄴ렉시컬환경 = {
        -환경레코드
        -외부환경 렉시컬 환경 참조
        -환경 레코드에 함수 안의 함수 변수 기록
        -외부 렉시컬 환경 참조에 가장 근접한 스코프 기록
    }
-함수/변수 검색방법
    ㄴ환경 레코드에서 검색, 없으면 외부 렉시컬 환경 참조에서 검색
-소스 코드 작성 최적화 방법
    ㄴ되도록 1단계 안에 변수 함수 작성
    ㄴ단계 밖의 환경이 스코프이며 외부 렉시컬 환경 참조에 설정되기 때

객체와 오브젝트

외부렉시컬 환경 참조
-장점
    ㄴ근접한 렉시컬 환경의 논리적 연결을 통해 현재 렉시컬 환경에 영향을 미치지않고 1단계 밖 스코프의 프로퍼티를 이동하지않고 사용
    ㄴ스코프 체인과 외부 렉시컬 환경 참조 차이
        ㄴEs3: 스코프 체인으로 근접함 스코프 인식을 위한 별도 처리필요
        ㄴ렉시컬환경 실행 콘텍스트에 근접한 스코프를 갖고있으면 별도의 처리없이 프로퍼티 접근 가능

환경 레코드 구분
-구분 이유
    ㄴ기록 대상에 따라 처리방법이 다르기때문
-선언적 환경 레코드
    ㄴfunction, 변수 catch문에 사ㅛㅇ
-오브젝트 환경레코드


